/*
 * SPDX-FileCopyrightText: Copyright (C) 2025 Altera Corporation
 *
 * SPDX-License-Identifier: MIT-0
 *
 * Header file for Events sub-module of SoC FPGA USB3.1 XHCI low level driver
 */

#ifndef __XHCI_EVENTS_H__
#define __XHCI_EVENTS_H__

#include <stdbool.h>
#include "xhci.h"
#include "xhci_commands.h"

/* XHCI specific event completion codes */
#define EVENT_SUCCESS         (1U)

#define PORTSC_REG_OFFSET     (0x00000400UL)    /*!< XHCI PORTSC register offset */

#define PORTSC_CLEAR_FLAGS    (0x80FF01FFU)     /*!< flag used to reset any of the PORTSC register status flags */

typedef enum
{
    DATA_BUFFER_ERROR = 2,              /* !< HC is unable to keep up with reception of data*/
    BABBLE_DETECTED_ERROR,              /* !< Babbling is detected during the transaction generated by this TRB */
    USB_TRANSACTION_ERROR,              /* !< Host did not receive a valid response from device */
    TRB_ERROR,                          /* !< Asserted when a TRB parameter error has occurred */
    STALL_ERROR,                        /* !< Asserted due to a stall condition */

    PARAMETER_ERROR = 17,               /* !< Asserted by a command if the context parameter is invalid */
    CONTEXT_STATE_ERROR = 19,           /* !< Asserted if transition is made from illegal context state */
    COMMAND_RING_STOPPED = 24,          /* !< Asserted due to a Command Stop operation */
    STOPPED_LENGTH_INVALID =27          /* !< Asserted in a Transfer Event if the transfer was terminated by a Stop
                                           Endpoint Command and the Transfer Event TRB Transfer Length field is
                                           invalid*/
}xhci_completion_code_t;

/* XHCI specific EVENT Identification codes */
typedef enum
{
    TRANSFER_EVENT = 32,                /* !< Transfer event TRB id */
    COMMAND_COMPLETION_EVENT,           /* !< Command Completion event TRB id */
    PORT_STATUS_CHANGE_EVENT,           /* !< PSCEG event TRB id */
}xhci_event_trb_type_t;

/* @struct  xtc_event_t
 * @brief   structure to store the transfer completion Event TRB data
 */
typedef struct __attribute__ ((packed))
{
    uint64_t tr_trb_ptr;                /* !< address of the TRB that generated this event */
    union
    {
        struct transfer_compl_status_field
        {
            uint32_t transfer_len : 24;  /* !< Number of bytes transferred */
            uint32_t compl_code : 8;     /* !< completion code of this event */
        } tc_status_params __attribute__ ((packed));
        uint32_t status_field;
    };
    union
    {
        struct trasfer_compl_ctrl_field
        {
            uint32_t cbit    : 1;       /* !< cycle bit */
            uint32_t rzvd0   : 1;       /* !< reserved */
            uint32_t ed_bit  : 1;       /* !< Event Data bit.When set to ‘1’, the event was generated by an Event Data TRB and the
                                           Parameter Component (TRB Pointer field) contains a 64-bit value provided by the Event Data
                                           TRB. If cleared to ‘0’, the Parameter Component (TRB Pointer field) contains a pointer to the TRB
                                           that generated this event.*/
            uint32_t rzvd1   : 7;       /* !< reserved */
            uint32_t trb_id  : 6;       /* !< TRB id */
            uint32_t ep_dci  : 5;       /* !< Endpoint id through which the transfer occurred */
            uint32_t rzvd2   : 3;       /* !< reserved */
            uint32_t slot_id : 8;       /* !< Slot id of the associated context*/
        } tc_ctrl_params __attribute__ ((packed));
        uint32_t control_field;
    };

} xtc_event_t;

/* @struct  xpsc_event_t
 * @brief   structure to store the PSC completion Event TRB data
 */
typedef struct __attribute__ ((packed))
{
    uint64_t buf;               /* !< Stores the port id of the port that generated this event */
    union
    {
        struct psc_status_field
        {
            uint32_t rzvd : 24;      /* !< reserved */
            uint32_t compl_code : 8; /* !< Completion code of this event. It is always one for PSCEG */
        } psc_status_params __attribute__ ((packed));
        uint32_t status_field;
    };
    union
    {
        struct psc_ctrl_field
        {
            uint32_t cbit    : 1;   /* !< cycle bit */
            uint32_t rzvd1   : 9;   /* !< reserved */
            uint32_t trb_id  : 6;   /* !< trb id  */
            uint32_t rzvd2   : 16;  /* !< reserved */
        } psc_event __attribute__ ((packed));
        uint32_t control_field;
    };

} xpsc_event_t;

/* @struct  generic_event_trb
 * @brief   generic structure template for event trb
 */
struct generic_event_trb
{
    uint64_t buffer;            /* !< buffer field of a trb */
    uint32_t status;            /* !< Status field of a trb */
    union
    {
        uint32_t control_field;
        struct ctrl_flags
        {
            uint32_t cbit : 1;      /* !< cycle bit */
            uint32_t rzvd0 : 9;     /* !< reserved */
            uint32_t trb_type : 6;  /* !< trb id  */
            uint32_t rzvd1 : 16;    /* !< reserved */
        } trb_control_field __attribute__ ((packed));
    };
};

typedef union
{
    xcc_event_t cc_event;
    xtc_event_t tr_event;
    xpsc_event_t psc_event;
    struct generic_event_trb event_trb;
}xhci_event_trb_t;

/* Structure to store the event ring parameters */
typedef struct
{
    uint32_t rhport;        /* !< root hub port id of the device*/
    int dev_attach_flag;    /* !< 1 indicated device attach,  0 indicated device detach */
}xhci_psceg_params_t;

/*
 * @brief  function to display the event ring TRBs
 * @param[in]  xhci reference to xhci data structure
 */
void display_event_trbs(struct xhci_data *xhci);

/*
 * @brief get the xhci event from the event ring
 * @param[in]  xhci reference to xhci data structure
 * @return
 *   event ring parameters
 */
xhci_event_trb_t get_xhc_event(struct xhci_data *xhci_ptr);

/*
 * @brief  Get the xhci RH port  link speed
 * @param[in] rhport rh port id of the corresponding port
 */
uint8_t get_xhc_port_speed(uint8_t rhport);

/*
 * @brief  get the RH port conntect status
 * @param[in] rhport  rh port id of the corresponding port
 */
bool xhci_port_status(uint8_t rhport);

/*
 * @brief  check if rh port reset is completed
 * @param[in] rhport  rh port id of the corresponding port
 * @return
 *  true  if port reset ends successfully
 *  false if port reset is unsuccessful
 */
bool is_xhci_port_reset_end(uint8_t rhport);

/*
 * @brief  reset the xhci RH port
 * @param[in] rhport  rh port id of the corresponding port
 */
void reset_xhci_port(uint8_t rhport);

/*
 * @brief handle all the PSCEG event
 * @param[in] psc_event PSCEG event TRB
 * @return port number and attach/detach flag
 */
xhci_psceg_params_t handle_psceg_event(xpsc_event_t psc_event);

/*
 * @brief update the device address in the xhci structure
 * @param[in]  xhci -  reference of xhci hcd controller
 */
void update_device_address(struct xhci_data *xhci_ptr);

/*
 * @brief update the device speed in the xhci structure
 * @param[in]  xhci_ptr -  reference of xhci hcd controller
 */
void update_device_dev_speed(struct xhci_data *xhci_ptr);

/*
 * @brief update the device slot id  in the xhci structure
 * @param[in]  dev_data -  reference of xhci_device_data structure
 * @param[in]  slot_id  -  slot id of the attached device
 */
void update_device_slot_id(struct xhci_device_data *dev_data, uint8_t slot_id);

/*
 * @brief  update the device roothub parameters in the xhci structure
 * @param[in]  xhci_ptr   -  reference of xhci hcd controller
 * @param[in]  rh_params  -  roothub parameters
 */
void update_device_rh_params(struct xhci_data *xhci_ptr,
        xhci_psceg_params_t rh_params);

/*
 * @brief Issue warm reset
 * @param[in] rhport The port id for which WR should be done
 */
void xhci_warm_reset(uint8_t rhport);

#endif  /* __XHCI_EVENTS_H__ */
